#include "drivers/w25q256.h"
#include "util/log.h"

// Define the QSPI handle. The variable name generated by cubeMX is reserved here to facilitate user reference and
// transplantation
//
///* QSPI initialization */
// void HAL_QSPI_MspInit(QSPI_HandleTypeDef* hqspi)
//{
//     GPIO_InitTypeDef GPIO_InitStruct = {0};
//     if(hqspi->Instance==QUADSPI)
//     {
//         __HAL_RCC_QSPI_CLK_ENABLE();	// Enable QSPI clock
//
//         GPIO_QUADSPI_CLK_ENABLE;		// Enable QUADSPI_CLK IO port clock
//         GPIO_QUADSPI_BK1_NCS_ENABLE;	// Enable QUADSPI_BK1_NCS IO port clock
//         GPIO_QUADSPI_BK1_IO0_ENABLE;	// Enable QUADSPI_BK1_IO0 IO port clock
//         GPIO_QUADSPI_BK1_IO1_ENABLE;	// Enable QUADSPI_BK1_IO1 IO port clock
//         GPIO_QUADSPI_BK1_IO2_ENABLE;	// Enable QUADSPI_BK1_IO2 IO port clock
//         GPIO_QUADSPI_BK1_IO3_ENABLE;	// Enable QUADSPI_BK1_IO3 IO port clock
//
//         /******************************************************
//         PB2     ------> QUADSPI_CLK
//         PB6     ------> QUADSPI_BK1_NCS
//         PD11    ------> QUADSPI_BK1_IO0
//         PD12    ------> QUADSPI_BK1_IO1
//         PE2     ------> QUADSPI_BK1_IO2
//         PD13    ------> QUADSPI_BK1_IO3
//         *******************************************************/
//
//         GPIO_InitStruct.Mode 		= GPIO_MODE_AF_PP;				// Multiplexing push
//         pull output mode GPIO_InitStruct.Pull 		= GPIO_NOPULL; // No up and down GPIO_InitStruct.Speed
//         = GPIO_SPEED_FREQ_VERY_HIGH;	// Ultra high speed IO port speed
//
//         GPIO_InitStruct.Pin 			= QUADSPI_CLK_PIN;			// QUADSPI_CLK pin
//         GPIO_InitStruct.Alternate 	= QUADSPI_CLK_AF;				// QUADSPI_CLK reuse
//         HAL_GPIO_Init(QUADSPI_CLK_PORT, &GPIO_InitStruct);			// Initialize QUADSPI_CLK pin
//
//         GPIO_InitStruct.Pin 			= QUADSPI_BK1_NCS_PIN;		// QUADSPI_BK1_NCS pin
//         GPIO_InitStruct.Alternate 	= QUADSPI_BK1_NCS_AF;			// QUADSPI_BK1_NCS reuse
//         HAL_GPIO_Init(QUADSPI_BK1_NCS_PORT, &GPIO_InitStruct);   	// Initialize QUADSPI_BK1_NCS pin
//
//         GPIO_InitStruct.Pin 			= QUADSPI_BK1_IO0_PIN;		// QUADSPI_BK1_IO0 pin
//         GPIO_InitStruct.Alternate 	= QUADSPI_BK1_IO0_AF;			// QUADSPI_BK1_IO0 reuse
//         HAL_GPIO_Init(QUADSPI_BK1_IO0_PORT, &GPIO_InitStruct);		// Initialize QUADSPI_BK1_IO0 pin
//
//         GPIO_InitStruct.Pin 			= QUADSPI_BK1_IO1_PIN;		// QUADSPI_BK1_IO1 pin
//         GPIO_InitStruct.Alternate 	= QUADSPI_BK1_IO1_AF;			// QUADSPI_BK1_IO1 reuse
//         HAL_GPIO_Init(QUADSPI_BK1_IO1_PORT, &GPIO_InitStruct);   	// Initialize QUADSPI_BK1_IO1 pin
//
//         GPIO_InitStruct.Pin 			= QUADSPI_BK1_IO2_PIN;		// QUADSPI_BK1_IO2 pin
//         GPIO_InitStruct.Alternate 	= QUADSPI_BK1_IO2_AF;			// QUADSPI_BK1_IO2 reuse
//         HAL_GPIO_Init(QUADSPI_BK1_IO2_PORT, &GPIO_InitStruct);		// Initialize QUADSPI_BK1_IO2 pin
//
//         GPIO_InitStruct.Pin 			= QUADSPI_BK1_IO3_PIN;		// QUADSPI_BK1_IO3 pin
//         GPIO_InitStruct.Alternate 	= QUADSPI_BK1_IO3_AF;			// QUADSPI_BK1_IO3 reuse
//         HAL_GPIO_Init(QUADSPI_BK1_IO3_PORT, &GPIO_InitStruct);		// Initialize QUADSPI_BK1_IO3 pin
//     }
// }

// Write enable
int8_t QSPI_W25Qxx_WriteEnable(void) {
  QSPI_CommandTypeDef s_command;     // QSPI transport configuration
  QSPI_AutoPollingTypeDef s_config;  // Polling comparison related configuration parameters

  s_command.InstructionMode = QSPI_INSTRUCTION_1_LINE;      // One line command mode
  s_command.AddressMode = QSPI_ADDRESS_NONE;                // No address mode
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  // No alternate bytes
  s_command.DdrMode = QSPI_DDR_MODE_DISABLE;                // Disable DDR mode
  s_command.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;   // Data delay in DDR mode is not used here
  s_command.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;   // Every time the data is transmitted, an instruction is sent
  s_command.DataMode = QSPI_DATA_NONE;             // No data mode
  s_command.DummyCycles = 0;                       // Number of empty periods
  s_command.Instruction = W25Qxx_CMD_WriteEnable;  // Send write enable command

  // Send write enable command
  if (HAL_QSPI_Command(&hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) return W25Qxx_ERROR_WRITEENABLE;
  // Keep querying W25Qxx_CMD_ReadStatus_REG1 register, read w25qxx in the status byte_ Status_ REG1_ Wel is compared
  // with 0x02 Read status register 1 bit 1 (read-only), WEL write enable flag bit. When the flag bit is 1, it means
  // that write operation can be performed

  s_config.Match = 0x02;                   // Match value
  s_config.Mask = W25Qxx_Status_REG1_WEL;  // Read status register 1 bit 1 (read-only), WEL write enable flag bit. When
  // the flag bit is 1, it means that write operation can be performed
  s_config.MatchMode = QSPI_MATCH_MODE_AND;             // Sum operation
  s_config.StatusBytesSize = 1;                         // Status bytes
  s_config.Interval = 0x10;                             // Polling interval
  s_config.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;  // Auto stop mode

  s_command.Instruction = W25Qxx_CMD_ReadStatus_REG1;  // Read status information register
  s_command.DataMode = QSPI_DATA_1_LINE;               // 1-line data mode
  s_command.NbData = 1;                                // Data length

  // Send polling wait command
  if (HAL_QSPI_AutoPolling(&hqspi, &s_command, &s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
    return W25Qxx_ERROR_AUTOPOLLING;  // Polling waiting for no response, error returned

  return QSPI_W25Qxx_OK;  // Communication ended normally
}

void MX_QUADSPI_Init(void) {
  hqspi.Instance = QUADSPI;  // QSPI peripherals

  // When the memory mapping mode is used, the frequency division coefficient here cannot be set to 0, otherwise the
  // reading error will occur
  hqspi.Init.ClockPrescaler = 1;  // The QSPI core clock is divided by 1 + 1 to get the QSPI communication driver clock
  hqspi.Init.FifoThreshold = 32;  // FIFO threshold
  hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_NONE;  // Sample after half CLK cycle
  hqspi.Init.FlashSize = 25;  // FLASH size, the number of bytes in FLASH = 2^[FSIZE+1], for 8MB W25Q64 set to 22
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE;  // Time for chip selection to keep high level
  hqspi.Init.ClockMode = QSPI_CLOCK_MODE_3;                   // Mode 0
  hqspi.Init.FlashID = QSPI_FLASH_ID_1;                       // Using QSPI1
  hqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE;              // Turn off dual flash mode
  // Application configuration
  HAL_QSPI_Init(&hqspi);
}

/* Check W25Q64 */
int8_t QSPI_W25Qxx_Init(void) {
  uint32_t Device_ID;

  // MX_QUADSPI_Init();                 // Initialize QSPI
  QSPI_W25Qxx_Reset();               // reset
  Device_ID = QSPI_W25Qxx_ReadID();  // Read ID

  // Check peripheral devices
  if (Device_ID == W25Qxx_FLASH_ID) {
    log_raw("W25Q64 OK,flash ID:%lX\r\n", Device_ID);  // Initialize successfully, print debug information
    return QSPI_W25Qxx_OK;                             // Return success flag
  } else {
    log_raw("W25Q64 ERROR!!!!!  ID:%lX\r\n", Device_ID);  // initialization failed
    return W25Qxx_ERROR_INIT;                             // Return error flag
  }
}

// Polling to confirm whether the FLASH is idle (used to wait for the end of communication, etc.)
int8_t QSPI_W25Qxx_AutoPollingMemReady(void) {
  QSPI_CommandTypeDef s_command;     // 	QSPI transport configuration
  QSPI_AutoPollingTypeDef s_config;  // 	Polling comparison related configuration parameters

  s_command.InstructionMode = QSPI_INSTRUCTION_1_LINE;      // 	One line command mode
  s_command.AddressMode = QSPI_ADDRESS_NONE;                // 	No address mode
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  //	No alternate bytes
  s_command.DdrMode = QSPI_DDR_MODE_DISABLE;                // 	Disable DDR mode
  s_command.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;   // 	Data delay in DDR mode is not used here
  s_command.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;       //	Every time the data is transmitted, an instruction is sent
  s_command.DataMode = QSPI_DATA_1_LINE;               // 	1-line data mode
  s_command.DummyCycles = 0;                           //	Number of empty periods
  s_command.Instruction = W25Qxx_CMD_ReadStatus_REG1;  // 	Read status information register

  // Keep querying W25Qxx_CMD_ReadStatus_REG1 register, read w25qxx in the status byte_ Status_ REG1_ Busy is compared
  // with 0 Read status register 1 bit 0 (read-only), Busy flag bit, when erasing / writing data / writing command will
  // be set to 1, idle or communication end to 0
  s_config.Match = 0;                                   //	Match value
  s_config.MatchMode = QSPI_MATCH_MODE_AND;             //	Sum operation
  s_config.Interval = 0x10;                             //	Polling interval
  s_config.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;  // Auto stop mode
  s_config.StatusBytesSize = 1;                         //	Status bytes
  s_config.Mask =
      W25Qxx_Status_REG1_BUSY;  // Mask the status bytes received in polling mode, and only compare the needed bits

  // Send polling wait command
  if (HAL_QSPI_AutoPolling(&hqspi, &s_command, &s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
    return W25Qxx_ERROR_AUTOPOLLING;  // Polling wait no response

  return QSPI_W25Qxx_OK;  // Communication ended normally
}

// FLASH software reset
int8_t QSPI_W25Qxx_Reset(void) {
  QSPI_CommandTypeDef s_command;  // QSPI transport configuration

  s_command.InstructionMode = QSPI_INSTRUCTION_1_LINE;      // One line command mode
  s_command.AddressMode = QSPI_ADDRESS_NONE;                // No address mode
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  // No alternate bytes
  s_command.DdrMode = QSPI_DDR_MODE_DISABLE;                // Disable DDR mode
  s_command.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;   // Data delay in DDR mode is not used here
  s_command.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;   // Every time the data is transmitted, an instruction is sent
  s_command.DataMode = QSPI_DATA_NONE;             // No data mode
  s_command.DummyCycles = 0;                       // Number of empty periods
  s_command.Instruction = W25Qxx_CMD_EnableReset;  // Execute reset enable command

  // Send reset enable command
  if (HAL_QSPI_Command(&hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
    return W25Qxx_ERROR_INIT;  // If the sending fails, an error message is returned
  // Use the automatic polling flag bit to wait for the end of communication
  if (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK) return W25Qxx_ERROR_AUTOPOLLING;  // Polling wait no response

  s_command.Instruction = W25Qxx_CMD_ResetDevice;  // Reset device command

  // Send reset device command
  if (HAL_QSPI_Command(&hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
    return W25Qxx_ERROR_INIT;  // If the sending fails, an error message is returned

  // Use the automatic polling flag bit to wait for the end of communication
  if (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK) return W25Qxx_ERROR_AUTOPOLLING;  // Polling wait no response

  if (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK) {
    return W25Qxx_ERROR_WRITEENABLE;
  }

  osDelay(1000);

  s_command.Instruction = 0x11;

  if (HAL_QSPI_Command(&hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
    return W25Qxx_ERROR_INIT;  // If the sending fails, an error message is returned

  uint8_t ucRegister3 = 0x62;
  // Start data transfer
  if (HAL_QSPI_Transmit(&hqspi, &ucRegister3, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
    return W25Qxx_ERROR_TRANSMIT;  // Transmission data error
  }

  // Use the automatic polling flag bit to wait for the end of communication
  if (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK) return W25Qxx_ERROR_AUTOPOLLING;  // Polling wait no response

  return QSPI_W25Qxx_OK;  // Reset successfully
}

uint32_t QSPI_W25Qxx_ReadID(void) {
  QSPI_CommandTypeDef s_command;  // QSPI transport configuration
  uint8_t QSPI_ReceiveBuff[3];    // Store data read by QSPI
  uint32_t W25Qxx_ID = 0;         // Device ID

  s_command.InstructionMode = QSPI_INSTRUCTION_1_LINE;      // One line command mode
  s_command.AddressSize = QSPI_ADDRESS_32_BITS;             // 24 bit address
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  // No alternate bytes
  s_command.DdrMode = QSPI_DDR_MODE_DISABLE;                // Disable DDR mode
  s_command.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;   // Data delay in DDR mode is not used here
  s_command.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;  // Every time the data is transmitted, an instruction is sent
  s_command.AddressMode = QSPI_ADDRESS_NONE;      // No address mode
  s_command.DataMode = QSPI_DATA_1_LINE;          // 1-line data mode
  s_command.DummyCycles = 0;                      // Number of empty periods
  s_command.NbData = 3;                           // Length of transmitted data
  s_command.Instruction = W25Qxx_CMD_JedecID;     // Execute read device ID command

  // Send command
  if (HAL_QSPI_Command(&hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
    return W25Qxx_ERROR_INIT;  // If the sending fails, an error message is returned
  // receive data
  if (HAL_QSPI_Receive(&hqspi, QSPI_ReceiveBuff, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
    return W25Qxx_ERROR_TRANSMIT;  // If the reception fails, an error message is returned

  // Combine the obtained data into ID
  W25Qxx_ID = (QSPI_ReceiveBuff[0] << 16) | (QSPI_ReceiveBuff[1] << 8) | QSPI_ReceiveBuff[2];
  return W25Qxx_ID;  // Return ID
}

uint8_t QSPI_W25Qxx_ReadStatus1(void) {
  QSPI_CommandTypeDef s_command;  // QSPI transport configuration
  uint8_t QSPI_ReceiveBuff;       // Store data read by QSPI

  s_command.InstructionMode = QSPI_INSTRUCTION_1_LINE;      // One line command mode
  s_command.AddressSize = QSPI_ADDRESS_32_BITS;             // 24 bit address
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  // No alternate bytes
  s_command.DdrMode = QSPI_DDR_MODE_DISABLE;                // Disable DDR mode
  s_command.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;   // Data delay in DDR mode is not used here
  s_command.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;       // Every time the data is transmitted, an instruction is sent
  s_command.AddressMode = QSPI_ADDRESS_NONE;           // No address mode
  s_command.DataMode = QSPI_DATA_1_LINE;               // 1-line data mode
  s_command.DummyCycles = 0;                           // Number of empty periods
  s_command.NbData = 1;                                // Length of transmitted data
  s_command.Instruction = W25Qxx_CMD_ReadStatus_REG1;  // Execute read device ID command

  // Send command
  if (HAL_QSPI_Command(&hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
    return W25Qxx_ERROR_INIT;  // If the sending fails, an error message is returned
  // receive data
  if (HAL_QSPI_Receive(&hqspi, &QSPI_ReceiveBuff, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
    return W25Qxx_ERROR_TRANSMIT;  // If the reception fails, an error message is returned

  return QSPI_ReceiveBuff;  // Return ID
}

uint8_t QSPI_W25Qxx_ReadStatus2(void) {
  QSPI_CommandTypeDef s_command;  // QSPI transport configuration
  uint8_t QSPI_ReceiveBuff;       // Store data read by QSPI

  s_command.InstructionMode = QSPI_INSTRUCTION_1_LINE;      // One line command mode
  s_command.AddressSize = QSPI_ADDRESS_32_BITS;             // 24 bit address
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  // No alternate bytes
  s_command.DdrMode = QSPI_DDR_MODE_DISABLE;                // Disable DDR mode
  s_command.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;   // Data delay in DDR mode is not used here
  s_command.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;       // Every time the data is transmitted, an instruction is sent
  s_command.AddressMode = QSPI_ADDRESS_NONE;           // No address mode
  s_command.DataMode = QSPI_DATA_1_LINE;               // 1-line data mode
  s_command.DummyCycles = 0;                           // Number of empty periods
  s_command.NbData = 1;                                // Length of transmitted data
  s_command.Instruction = W25Qxx_CMD_ReadStatus_REG2;  // Execute read device ID command

  // Send command
  if (HAL_QSPI_Command(&hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
    return W25Qxx_ERROR_INIT;  // If the sending fails, an error message is returned
  // receive data
  if (HAL_QSPI_Receive(&hqspi, &QSPI_ReceiveBuff, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
    return W25Qxx_ERROR_TRANSMIT;  // If the reception fails, an error message is returned

  return QSPI_ReceiveBuff;  // Return ID
}

uint8_t QSPI_W25Qxx_ReadStatus3(void) {
  QSPI_CommandTypeDef s_command;  // QSPI transport configuration
  uint8_t QSPI_ReceiveBuff;       // Store data read by QSPI

  s_command.InstructionMode = QSPI_INSTRUCTION_1_LINE;      // One line command mode
  s_command.AddressSize = QSPI_ADDRESS_32_BITS;             // 24 bit address
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  // No alternate bytes
  s_command.DdrMode = QSPI_DDR_MODE_DISABLE;                // Disable DDR mode
  s_command.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;   // Data delay in DDR mode is not used here
  s_command.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;       // Every time the data is transmitted, an instruction is sent
  s_command.AddressMode = QSPI_ADDRESS_NONE;           // No address mode
  s_command.DataMode = QSPI_DATA_1_LINE;               // 1-line data mode
  s_command.DummyCycles = 0;                           // Number of empty periods
  s_command.NbData = 1;                                // Length of transmitted data
  s_command.Instruction = W25Qxx_CMD_ReadStatus_REG3;  // Execute read device ID command

  // Send command
  if (HAL_QSPI_Command(&hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
    return W25Qxx_ERROR_INIT;  // If the sending fails, an error message is returned
  // receive data
  if (HAL_QSPI_Receive(&hqspi, &QSPI_ReceiveBuff, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
    return W25Qxx_ERROR_TRANSMIT;  // If the reception fails, an error message is returned

  return QSPI_ReceiveBuff;  // Return ID
}

// Set QSPI to memory mapping mode
// This mode is read-only and cannot be written
int8_t QSPI_W25Qxx_MemoryMappedMode(void) {
  QSPI_CommandTypeDef s_command;              // QSPI transport configuration
  QSPI_MemoryMappedTypeDef s_mem_mapped_cfg;  // Memory mapped access parameters

  s_command.InstructionMode = QSPI_INSTRUCTION_1_LINE;      // One line command mode
  s_command.AddressSize = QSPI_ADDRESS_32_BITS;             // 24 bit address
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  // No alternate bytes
  s_command.DdrMode = QSPI_DDR_MODE_DISABLE;                // Disable DDR mode
  s_command.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;   // Data delay in DDR mode is not used here
  s_command.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;       // Every time the data is transmitted, an instruction is sent
  s_command.AddressMode = QSPI_ADDRESS_4_LINES;        // 4-wire address mode
  s_command.DataMode = QSPI_DATA_4_LINES;              // 4-wire data mode
  s_command.DummyCycles = 6;                           // Number of empty periods
  s_command.Instruction = W25Qxx_CMD_FastReadQuad_IO;  // 1-4-4 mode (1 line instruction, 4 line address, 4 line data),
                                                       // fast read instruction

  s_mem_mapped_cfg.TimeOutActivation =
      QSPI_TIMEOUT_COUNTER_DISABLE;    // Disable the timeout counter and keep the nCS active
  s_mem_mapped_cfg.TimeOutPeriod = 0;  // Timeout judgment cycle

  QSPI_W25Qxx_Reset();  // Reset W25Qxx

  if (HAL_QSPI_MemoryMapped(&hqspi, &s_command, &s_mem_mapped_cfg) != HAL_OK)  // Configure
    return W25Qxx_ERROR_MemoryMapped;                                          // Error setting memory mapping mode

  return QSPI_W25Qxx_OK;  // Configuration successful
}

/* Erase */
// Here, the original document is copied, and the instructions are repeated without comment
int8_t QSPI_W25Qxx_SectorErase(uint32_t SectorAddress) {
  QSPI_CommandTypeDef s_command;  // QSPI transport configuration

  s_command.InstructionMode = QSPI_INSTRUCTION_1_LINE;      // One line command mode
  s_command.AddressSize = QSPI_ADDRESS_32_BITS;             // 24 bit address mode
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  //	No alternate bytes
  s_command.DdrMode = QSPI_DDR_MODE_DISABLE;                // Disable DDR mode
  s_command.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;   // Data delay in DDR mode is not used here
  s_command.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;   // Every time the data is transmitted, an instruction is sent
  s_command.AddressMode = QSPI_ADDRESS_1_LINE;     // 1-line address mode
  s_command.DataMode = QSPI_DATA_NONE;             // No data
  s_command.DummyCycles = 0;                       // Number of empty periods
  s_command.Address = SectorAddress;               // Address to erase
  s_command.Instruction = W25Qxx_CMD_SectorErase;  // Sector erase command

  // Send write enable
  if (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK) {
    return W25Qxx_ERROR_WRITEENABLE;  // Write enable failed
  }
  // Issue erase command
  if (HAL_QSPI_Command(&hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
    return W25Qxx_ERROR_Erase;  // Erase failed
  }
  // Use the automatic polling flag bit to wait for the end of erasure
  if (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK) {
    return W25Qxx_ERROR_AUTOPOLLING;  // Polling wait no response
  }
  return QSPI_W25Qxx_OK;  // Erase succeeded
}

bool QSPI_W25Qxx_is_empty_sector(uint32_t address) {
  uint8_t buf[32];
  uint32_t i;
  for (i = 0; i < 4096; i += 32) {
    QSPI_W25Qxx_ReadBuffer(buf, address, 32);
    if (buf[31] != 0xFF) break;
  }
  if (i < 4096)
    return false;
  else
    return true;
}
//
// int8_t QSPI_W25Qxx_BlockErase_32K(uint32_t SectorAddress) {
//  QSPI_CommandTypeDef s_command;  // QSPI transport configuration
//
//  s_command.InstructionMode = QSPI_INSTRUCTION_1_LINE;      // One line command mode
//  s_command.AddressSize = QSPI_ADDRESS_32_BITS;             // 24 bit address mode
//  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  //	No alternate bytes
//  s_command.DdrMode = QSPI_DDR_MODE_DISABLE;                // Disable DDR mode
//  s_command.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;   // Data delay in DDR mode is not used here
//  s_command.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;      // Every time the data is transmitted, an instruction is sent
//  s_command.AddressMode = QSPI_ADDRESS_1_LINE;        // 1-line address mode
//  s_command.DataMode = QSPI_DATA_NONE;                // No data
//  s_command.DummyCycles = 0;                          // Number of empty periods
//  s_command.Address = SectorAddress;                  // Address to erase
//  s_command.Instruction = W25Qxx_CMD_BlockErase_32K;  // Block erase command, each erase 32K bytes
//
//  // Send write enable
//  if (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK) {
//    return W25Qxx_ERROR_WRITEENABLE;  // Write enable failed
//  }
//  // Issue erase command
//  if (HAL_QSPI_Command(&hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
//    return W25Qxx_ERROR_Erase;  // Erase failed
//  }
//  // Use the automatic polling flag bit to wait for the end of erasure
//  if (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK) {
//    return W25Qxx_ERROR_AUTOPOLLING;  // Polling wait no response
//  }
//  return QSPI_W25Qxx_OK;  // Erase succeeded
//}

int8_t QSPI_W25Qxx_BlockErase_64K(uint32_t SectorAddress) {
  QSPI_CommandTypeDef s_command;  // QSPI transport configuration

  s_command.InstructionMode = QSPI_INSTRUCTION_1_LINE;      // One line command mode
  s_command.AddressSize = QSPI_ADDRESS_32_BITS;             // 24 bit address mode
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  //	No alternate bytes
  s_command.DdrMode = QSPI_DDR_MODE_DISABLE;                // Disable DDR mode
  s_command.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;   // Data delay in DDR mode is not used here
  s_command.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;      // Every time the data is transmitted, an instruction is sent
  s_command.AddressMode = QSPI_ADDRESS_1_LINE;        // 1-line address mode
  s_command.DataMode = QSPI_DATA_NONE;                // No data
  s_command.DummyCycles = 0;                          // Number of empty periods
  s_command.Address = SectorAddress;                  // Address to erase
  s_command.Instruction = W25Qxx_CMD_BlockErase_64K;  // Block erase command, erase 64K bytes each time

  // Send write enable
  if (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK) {
    return W25Qxx_ERROR_WRITEENABLE;  // Write enable failed
  }
  // Issue erase command
  if (HAL_QSPI_Command(&hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
    return W25Qxx_ERROR_Erase;  // Erase failed
  }
  // Use the automatic polling flag bit to wait for the end of erasure
  if (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK) {
    return W25Qxx_ERROR_AUTOPOLLING;  // Polling wait no response
  }
  return QSPI_W25Qxx_OK;  // Erase succeeded
}

int8_t QSPI_W25Qxx_ChipErase(void) {
  QSPI_CommandTypeDef s_command;     // QSPI transport configuration
  QSPI_AutoPollingTypeDef s_config;  // Polling wait configuration parameters

  s_command.InstructionMode = QSPI_INSTRUCTION_1_LINE;      // One line command mode
  s_command.AddressSize = QSPI_ADDRESS_32_BITS;             // 24 bit address mode
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  //	No alternate bytes
  s_command.DdrMode = QSPI_DDR_MODE_DISABLE;                // Disable DDR mode
  s_command.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;   // Data delay in DDR mode is not used here
  s_command.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;  // Every time the data is transmitted, an instruction is sent
  s_command.AddressMode = QSPI_ADDRESS_NONE;      // No address
  s_command.DataMode = QSPI_DATA_NONE;            // No data
  s_command.DummyCycles = 0;                      // Number of empty periods
  s_command.Instruction = W25Qxx_CMD_ChipErase;   // Erase command to erase the whole piece

  // Send write enable
  if (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK) {
    return W25Qxx_ERROR_WRITEENABLE;  // Write enable failed
  }
  // Issue erase command
  if (HAL_QSPI_Command(&hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
    return W25Qxx_ERROR_Erase;  // Erase failed
  }

  // Keep querying W25Qxx_CMD_ReadStatus_REG1 register, read w25qxx in the status byte_ Status_ REG1_ Busy keeps
  // comparing with 0 Read status register 1 bit 0 (read-only), Busy flag bit, when erasing / writing data / writing
  // command will be set to 1, idle or communication end to 0

  s_config.Match = 0;                                   //	Match value
  s_config.MatchMode = QSPI_MATCH_MODE_AND;             //	Sum operation
  s_config.Interval = 0x10;                             //	Polling interval
  s_config.AutomaticStop = QSPI_AUTOMATIC_STOP_ENABLE;  // Auto stop mode
  s_config.StatusBytesSize = 1;                         //	Status bytes
  s_config.Mask =
      W25Qxx_Status_REG1_BUSY;  // Mask the status bytes received in polling mode, and only compare the needed bits

  s_command.Instruction = W25Qxx_CMD_ReadStatus_REG1;  // Read status information register
  s_command.DataMode = QSPI_DATA_1_LINE;               // 1-line data mode
  s_command.NbData = 1;                                // Data length

  // The typical reference time of W25Q64 whole chip erasure is 20s, and the maximum time is 100S. Here, the timeout
  // value W25Qxx_ChipErase_TIMEOUT_MAX is 100S
  if (HAL_QSPI_AutoPolling(&hqspi, &s_command, &s_config, W25Qxx_ChipErase_TIMEOUT_MAX) != HAL_OK) {
    return W25Qxx_ERROR_AUTOPOLLING;  // Polling wait no response
  }
  return QSPI_W25Qxx_OK;
}

/* write in */
int8_t QSPI_W25Qxx_WritePage(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite) {
  QSPI_CommandTypeDef s_command = {
      .InstructionMode = QSPI_INSTRUCTION_1_LINE,      // One line command mode
      .AddressSize = QSPI_ADDRESS_32_BITS,             // 24 bit address
      .AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE,  // No alternate bytes
      .DdrMode = QSPI_DDR_MODE_DISABLE,                // Disable DDR mode
      .DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY,   // Data delay in DDR mode is not used here
      .SIOOMode = QSPI_SIOO_INST_EVERY_CMD,            // Every time the data is transmitted, an instruction is sent
      .AddressMode = QSPI_ADDRESS_1_LINE,              // 1-line address mode
      .DataMode = QSPI_DATA_4_LINES,                   // 4-wire data mode
      .DummyCycles = 0,                                // Number of empty periods
      .NbData = NumByteToWrite,                        // The maximum length of data is 256 bytes
      .Address = WriteAddr,                            // Address to write to W25Qxx
      .Instruction = W25Qxx_CMD_QuadInputPageProgram,  // 1-1-4 mode (1 line instruction, 1 line address, 4 line data),
                                                       // page programming instruction
  };                                                   // QSPI transport configuration

  // Write enable
  if (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK) {
    return W25Qxx_ERROR_WRITEENABLE;  // Write enable failed
  }
  // Write command
  if (HAL_QSPI_Command(&hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
    return W25Qxx_ERROR_TRANSMIT;  // Transmission data error
  }
  // Start data transfer
  if (HAL_QSPI_Transmit(&hqspi, pBuffer, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
    return W25Qxx_ERROR_TRANSMIT;  // Transmission data error
  }
  // Use the automatic polling flag bit to wait for the end of the write
  if (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK) {
    return W25Qxx_ERROR_AUTOPOLLING;  // Polling wait no response
  }
  return QSPI_W25Qxx_OK;  // Write data successfully
}

int8_t QSPI_W25Qxx_WriteBuffer(uint8_t* pBuffer, uint32_t WriteAddr, uint32_t Size) {
  uint32_t end_addr, current_size, current_addr;
  uint8_t* write_data;  // Data to write

  current_size = W25Qxx_PageSize - (WriteAddr % W25Qxx_PageSize);  // Calculates the remaining space on the current page

  if (current_size > Size)  // Determine whether the remaining space of the current page is enough to write all data
  {
    current_size = Size;  // If it is enough, the current length is obtained directly
  }

  current_addr = WriteAddr;     // Get the address to write to
  end_addr = WriteAddr + Size;  // Calculation end address
  write_data = pBuffer;         // Gets the data to be written

  do {
    // Send write enable
    if (QSPI_W25Qxx_WriteEnable() != QSPI_W25Qxx_OK) {
      return W25Qxx_ERROR_WRITEENABLE;
    }

    // Write data by page
    else if (QSPI_W25Qxx_WritePage(write_data, current_addr, current_size) != QSPI_W25Qxx_OK) {
      return W25Qxx_ERROR_TRANSMIT;
    }

    // Use the automatic polling flag bit to wait for the end of the write
    else if (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK) {
      return W25Qxx_ERROR_AUTOPOLLING;
    }

    else  // Write data by page successfully, prepare for the next data write
    {
      current_addr += current_size;  // Calculate the next write address
      write_data += current_size;    // Gets the address of the data store to be written next time
      // Calculate the length of the next write
      current_size = ((current_addr + W25Qxx_PageSize) > end_addr) ? (end_addr - current_addr) : W25Qxx_PageSize;
    }
  } while (current_addr < end_addr);  // Judge whether all data are written

  return QSPI_W25Qxx_OK;  // Write data successfully
}

/* read */
int8_t QSPI_W25Qxx_ReadBuffer(uint8_t* pBuffer, uint32_t ReadAddr, uint32_t NumByteToRead) {
  QSPI_CommandTypeDef s_command = {};  // QSPI transport configuration

  s_command.InstructionMode = QSPI_INSTRUCTION_1_LINE;      // One line command mode
  s_command.AddressSize = QSPI_ADDRESS_32_BITS;             // 24 bit address
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;  // No alternate bytes
  s_command.DdrMode = QSPI_DDR_MODE_DISABLE;                // Disable DDR mode
  s_command.DdrHoldHalfCycle = QSPI_DDR_HHC_ANALOG_DELAY;   // Data delay in DDR mode is not used here
  s_command.SIOOMode = QSPI_SIOO_INST_EVERY_CMD;  // Every time the data is transmitted, an instruction is sent
  s_command.AddressMode = QSPI_ADDRESS_4_LINES;   // 4-wire address mode
  s_command.DataMode = QSPI_DATA_4_LINES;         // 4-wire data mode
  s_command.DummyCycles = 6;                      // Number of empty periods
  s_command.NbData = NumByteToRead;  // The maximum data length should not exceed the size of the flash chip
  s_command.Address = ReadAddr;      // To read the address of W25Qxx
  s_command.Instruction = W25Qxx_CMD_FastReadQuad_IO;  // 1-4-4 mode (1 line instruction, 4 line address, 4 line data),
                                                       // fast read instruction

  // Send read command
  if (HAL_QSPI_Command(&hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
    return W25Qxx_ERROR_TRANSMIT;  // Transmission data error
  }

  //	receive data

  if (HAL_QSPI_Receive(&hqspi, pBuffer, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK) {
    return W25Qxx_ERROR_TRANSMIT;  // Transmission data error
  }

  // Use automatic polling flag bits to wait for the end of reception
  if (QSPI_W25Qxx_AutoPollingMemReady() != QSPI_W25Qxx_OK) {
    return W25Qxx_ERROR_AUTOPOLLING;  // Polling wait no response
  }
  return QSPI_W25Qxx_OK;  // Read data successfully
}